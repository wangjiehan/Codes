'''
22.栈的压入、弹出序列：判断给定的两个序列中，后者是不是前者的弹出序列，给定栈不包含相同值
准备一个辅助栈，共三个栈：压栈，出栈，辅助栈。
压栈中记录的是真实压栈顺序，出栈中记录的是可能为真的出栈顺序。

考虑pushV栈为空或者pushV栈和popV栈尺寸不一的情况。
把数据从pushV中按pushV的入栈顺序（栈底元素）不断向stack中压：在压入循环中，
当stack的栈顶元素和popV的栈底元素一致时，就从stack的栈顶和popV的栈底同时弹出该数。
等pushV中元素全部走完，判断stack是否为空：若非空有剩余，返回False；else返回True。
'''
def IsPopOrder(pushV, popV):
	stack = []
	for i in pushV:		#从pushV中按pushV的入栈顺序（栈底元素）不断向stack中压
		stack.append(i)
		while popV and stack[-1] == popV[0]:	#stack的栈顶元素和popV的栈底元素比较
			stack.pop()							#注意popV非空的条件
			popV.pop(0)			#两个序列同时弹
	if stack != []:
		return False
	return True
'''
入栈1,2,3,4,5
出栈4,5,3,2,1
首先1入辅助栈，此时栈顶1≠4，继续入栈2
此时栈顶2≠4，继续入栈3
此时栈顶3≠4，继续入栈4
此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3
此时栈顶3≠5，继续入栈5
此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3
….
依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。
'''
