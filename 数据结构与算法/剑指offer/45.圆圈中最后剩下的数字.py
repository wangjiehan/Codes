'''
45.圆圈中最后剩下的数字
要求：0到n-1排成一圈，从0开始每次数m个数删除，求最后剩余的数
思路：时间复杂度O(N)，空间复杂度O(1)
f(n, m)表示每次在n个数字中删除第m个数字最后剩下的数字。
假设从0到n-1中删除了第m个数字(m-1位置)，则下一轮的数字排列为m,m+1,...n,1,2,3...m-2，
将该数字排列重新映射为0~n-2，则为：
m		0
m+1	  	1
....	....
n-1		n-1-m
0		n-m				#此时左侧left对应f(n)，右侧right对应f(n-1)
1		n-m+1
...		....
m-2		n-2
可看出从右往左（逆向）的映射关系为left=(right+m)%n；当n=1时只有一个数，即剩下的数字就是0。
当 n > 1 时： f(n,m) = (f(n-1,m) + m) % n，
当 n = 1 时： f(n,m) = 0			#动态规划最初开始
动态规划问题（也可改写为递归）
'''
def LastRemaining_Solution(n, m):
	if n == 1:					#n=1时，也可以和下面循环合并起来写
		return 0
	res = 0						#初始化f(1) = 0，只需求第n个，无需申请数组存储过程
	for i in range(2, n+1):		#从f(2)开始，动态规划到f(n)，一共n-1次
		res = (res + m) % i		#f(2,m) = (f(1,m) + m) % 2
	return res
if __name__ == '__main__':
	print(LastRemaining_Solution(6, 2))
